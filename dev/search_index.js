var documenterSearchIndex = {"docs":
[{"location":"#DeepViz.jl-1","page":"Home","title":"DeepViz.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [DeepViz]","category":"page"},{"location":"#DeepViz.ImageGenerator-Tuple{Any,Int64}","page":"Home","title":"DeepViz.ImageGenerator","text":"ImageGenerator(model, target_class)\n\nFunction to initialize the ImageGenerator for the model and target_class. Returns a struct with fields model, img and target. Here, the image is randomly generated which is then to be further updated.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.ImageGenerator-Tuple{Any}","page":"Home","title":"DeepViz.ImageGenerator","text":"ImageGenerator(save_dir; img_name = \"generated\", niters::Int = 150, lr = 6.0)\n\nGenerates the image for which the prediction probability is maximized for a target class after niter iterations using backpropagation. Before using this function, the ImageGenerator must be initialized using ImageGenerator(model, target_class).\n\nArguments\n\nsave_dir: Directory to which the generated image is to be saved \nimg_name=\"generated\": Image name with which file is to be saved withoout file extension\nniters::Int=150: number of iterations for which the generated image is updated with backpropagation\nlr=6.0: Learning rate to be used while updating the generated image with respect to backpropagated gradients to maximize the specific class.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.apply_colormap-Tuple{Any,Any}","page":"Home","title":"DeepViz.apply_colormap","text":"apple_colormap(org_img, activation_map; map_alpha=0.4, process_img=true)\n\nCreates a rainbow based colormap for the image, which is then applied onto org_img(original image) with different transparency to generate the combined heatmap with the org_img (original image). Function returns a tuple of combined colormap and activation map alone based heatmap.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.generate_image-Tuple{Any}","page":"Home","title":"DeepViz.generate_image","text":" generate_image(x; resize_original=false, custom_size=Nothing)\n\nSave the image as an RGB image defined the by the array x. If resize_original is set to be true, then the image can be resized to the custom_size. If not provided explicitly, then the image is resized to the original_size of the image saved while loading the image or the default one(ie. (224, 224)) \n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.grad_times_image-Tuple{Any,Any}","page":"Home","title":"DeepViz.grad_times_image","text":"grad_times_image(img, model; top_k=1)\n\nAn extension to the saliency approach. Returns an array of products of the img with the gradient evaluated with respect to the provided img for the model, for top_k prediction classes. \n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.image_to_arr-Tuple{Any}","page":"Home","title":"DeepViz.image_to_arr","text":"image_to_arr(img; preprocess = true)\n\nConvert an RGB type image to an array. If preprocess is set as true, subtract the mean from the image array.  \n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.load_image","page":"Home","title":"DeepViz.load_image","text":"load_image(path, resize = false; size_save = true)\n\nFunction to load the images from the specified path. Returns as an array of image. If resize is set as true, resize the image to shape (224, 224). \n\n\n\n\n\n","category":"function"},{"location":"#DeepViz.positive_negative_saliency-Tuple{Any}","page":"Home","title":"DeepViz.positive_negative_saliency","text":"positive_negative_saliency(gradient)\n\nReturns a tuple of positive and negative saliency maps based on the provided gradients.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.save_gradcam-NTuple{5,Any}","page":"Home","title":"DeepViz.save_gradcam","text":"save_gradcam(gradient, original_image_path, grad_file_name, heatmap_file_name, combined_file_name)\n\nFunction to save the gradient calculated using gradcam as a gray image, gradient heatmap and the combined heatmap with different transparency.\n\nArguments\n\ngradient: Gradient calculated using the viz_gradcam function\noriginal_image_path: Path to the original image file, for which the gradient is calculated.\ngrad_file_name: Filename with path, to which the gradient image is to be saved as a gray image\nheatmap_file_name: Filename to save the gradient heatmap\ncombined_file_name: Filename to save the gradient the combined heatmap with original image.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.save_gradient_images-Tuple{Any,Any}","page":"Home","title":"DeepViz.save_gradient_images","text":"save_gradient_images(gradient, file_name; gray=false)\n\nSaves the gradient as an RGB image by default. If gray is set to true, gradients are sasved as a gray image with the provided filename.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.save_image-Tuple{Any,Any}","page":"Home","title":"DeepViz.save_image","text":"save_image(path, x)\n\nSave the image defined by x to the specified path.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.set_training_false-Tuple{}","page":"Home","title":"DeepViz.set_training_false","text":"set_training_false()\n\nFunction to set the model into testmode, so that the output result do not vary while evaluating gradients(or other results) for the models which contain layers like BatchNormalization, Dropout etc.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.set_training_true-Tuple{}","page":"Home","title":"DeepViz.set_training_true","text":"set_training_true()\n\nFunction to revert back the model into trainmode, once the gradients(or other results) are evaluated.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.smooth_grad-Tuple{Any,Any}","page":"Home","title":"DeepViz.smooth_grad","text":"smooth_grad(img, model; method=viz_backprop,top_k=1, mean=0, var=1, n_imgs=50, normalized_n_scaled=true)\n\nMethod to visually sharpen the gradient based saliency maps. The key idea is to evaluate the average of gradients of images obtained after adding gaussian noise to the original image(img). The results suggest the estimated smoothed gradient, leads to visually more coherent sensitivity maps than the unsmoothed gradient, with the resulting visualization aligning better to the human eye with meaningful features.\n\nArguments\n\nimg: Original image of interest for visualization\nmodel: Model to be used for visualization\nmethod=viz_backprop: Method to be used while evaluating gradients. Can take methods like viz_guidedbackprop, viz_backprop, viz_deconvolution or any other custom function.\ntop_k=1: function evaluates the smoothed gradient for top_k predictions just as in case of normal viz_backprop function.\nmean=0: Mean of the gaussian noise to be added to the image to generate sample space\nvar=1: Variance of the gaussian noise to be added to image to generate sample space\nn_imgs=50: Number of images to be generated and used in sample space while evaluation of smooth_grad.\nnormalized_n_scaled=true: if true, then the noise is first scaled to 0-255 before adding to the image. \n\nRef: (https://arxiv.org/pdf/1706.03825.pdf)\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.stepped_images-Tuple{Any,Any}","page":"Home","title":"DeepViz.stepped_images","text":"stepped_images(img, steps)\n\nUtility function for viz_integrated_gradient. Generate scaled images, ie. images multiplied by a factor i defined in the range of 0 to 1.0 over equal intervals of 1/steps. \n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_backprop-Tuple{Any,Any}","page":"Home","title":"DeepViz.viz_backprop","text":"viz_backprop(img, model; top_k=1, target_based=false, target_index)\n\nReturns gradient generated with Vanilla Backpropagation for top_k classes. Itâ€™s the original saliency map algorithm for supervised deep learning from Simonyan et. al. (2013). These gradients can further be visualized using utilty functions.\n\nArguments\n\nimg: source image for which gradients are to be calculated\nmodel: model to be used for visualization\ntop_k=1: gradients are returned for top_k classes as per predictions by the model.\ntarget_based=false: if set to true, function returns the maximizing gradient for the specified target_index class along with gradient for top_k classes.\ntarget_index: defines the target class, for which the maximizing gradients are to be calculated. Required when target_based is set to true. \n\nThe function returns an of gradients for top_k=1 predicted classes by default. If target_based is set to true and target_index is specified, the function returns a tuple: (gradients_for_top_k_classes, gradient_for_target_class).\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_deconvolution-Tuple{Any,Any}","page":"Home","title":"DeepViz.viz_deconvolution","text":"viz_deconvolution(img, model; top_k=1, target_based=false, target_index=-1)\n\nIn this method of Gradient visualization, the backpropagation of RELU activation function are overridden (so called Guided RELU) in such a way that only the non-negative gradients are backpropagated. Here, the guided RELU is applied onto the output gradients which stands as the main difference from the viz_guidedbackprop. Once the activation function is overridden, the gradient is evaluated here using the viz_backprop function.\n\nNote: The function currently doesn't support ResNet type models. See also: viz_backprop, viz_guidedbackprop\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_gradcam-Tuple{Any,Any,Any}","page":"Home","title":"DeepViz.viz_gradcam","text":"viz_gradcam(img, model, layer; top_k=1)\n\nLayer attribution method that computes the gradients of the target output with respect to the given layer, averages for each output channel (dimension 2 of output), and multiplies the average gradient for each channel by the layer activations. The results are summed over all channels.\n\nIt returns an array of tuples of (gradCAM, prediction_probability, class_index) for top_k predicted classes.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_guidedbackprop-Tuple{Any,Any}","page":"Home","title":"DeepViz.viz_guidedbackprop","text":"viz_guidedbackprop(img, model; top_k=1, target_based=false, target_index=-1)\n\nIn this method of Gradient visualization, the backpropagation of RELU activation function are overridden (so called Guided RELU) in such a way that only the non-negative gradients are backpropagated. Here, the guided RELU is applied onto the input gradients which stands as the main difference from the viz_deconvolution. Once the activation function is overridden, the gradient is evaluated here using the viz_backprop function.\n\nNote: The function currently doesn't support ResNet type models. See also: viz_backprop, viz_deconvolution\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_guidedgradcam-Tuple{Any,Any,Any}","page":"Home","title":"DeepViz.viz_guidedgradcam","text":"viz_guidedgradcam(img, model, layer; top_k=1)\n\nIt computes the element-wise product of guided backpropagation attributions (evaluated using viz_guidedbackprop) with resized (layer) GradCAM attributions (computed using viz_gradcam). GradCAM attributions are computed with respect to a given layer, and attributions are resized to match the input size.\n\nIt returns an array of tuples of (guidedgradcam, prediction_probability, class_index) for top_k predicted classes.\n\nAlso see: viz_guidedbackprop, viz_guidedgradcam.\n\n\n\n\n\n","category":"method"},{"location":"#DeepViz.viz_integrated_gradient-Tuple{Any,Any,Any}","page":"Home","title":"DeepViz.viz_integrated_gradient","text":"viz_integrated_gradient(img, model, steps; target_based=false, target_index)\n\nProduces gradients generated with integrated gradients from the image scaled over steps. This functions uses the viz_backprop for the calculation of gradients for each of scaled image and then returns integrated gradients as the average over all the scaled images.\n\nArguments\n\nimg: source image on which the gradient are to be calculated.\nmodel: model to be used for visualization\nsteps: number of steps between 0 to 1.0 for which the image is to be scaled while calculating integrated gradients.\ntarget_based=false: if set true, the integrated gradients are evaluated for the specified target_index.\ntarget_index: index of the target class for which the maximized gradients are to be evaluated. Necessary condition when target_based is set as true.\n\n\n\n\n\n","category":"method"}]
}
